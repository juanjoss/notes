# Escape Analysis

Escape analysis is a technique that the compiler uses to determine whether any references to a value escapes the function in which the value was created. If a reference to a value doesn't escape, the value will be placed on the stack, otherwise it will go to the heap.

The compiler always prefers stack over heap, since this reduces pressure on the garbage collector.

Which values ***could*** be constructed on the heap?
- Values that are referenced after the function that constructed the value returns (AKA returning pointers).
- Values that are too large to fit on the stack.
- The compiler doesn't know the size of the value at compile time.
- Values stored in `interface{}`.
- Func literals (anonymous functions).
- Maps, Channels, Slices and Strings ([]byte).

> *Sharing down **typically** stays on the stack. Sharing up **typically** escapes to the heap.*

## Example

In this example the only value that escapes to the heap is the `c` variable in `incrementByValue(c counter) *counter`, since the value it's being created by `incrementByValue` and then returned as a reference.

Note that `(c *counter) incrementByReference()` and `incrementByReference(c *counter)` are the same function, the first being a sintactic sugar of the second. 

Same for `(c counter) incrementByValue() counter` and `incrementByValue(c counter) *counter`, with the difference that the second returns a reference to the copied or created value inside the function. This is what the escape analysis will detect and the reason why the compiler will place `c` on the heap, after the reference to `c` is returned the compiler can no longer know if it'll be safe to access `c` or not. 

```go
package main

type counter int

func (c *counter) incrementByReference() {
	*c++
}

func (c counter) incrementByValue() counter {
	c++
	return c
}

func incrementByReference(c *counter) {
	*c++
}

func incrementByValue(c counter) *counter {
	c++
	return &c
}

func main() {
	c1 := new(counter)
	var c2 counter

	// increment c1
	c1.incrementByReference()
	*c1 = c1.incrementByValue()
	incrementByReference(c1)
	c1 = incrementByValue(*c1)

	println(*c1)

	// increment c2
	c2.incrementByReference()
	c2 = c2.incrementByValue()
	incrementByReference(&c2)
	c2 = *incrementByValue(c2)

	println(c2)
}
```

Output from the escape analysis during compilation. The `-gcflags '-m=1'` tells the compiler to show 1 level of escape analysis results (4 available).

```bash
go build -gcflags '-m=1' .
```

	./main.go:5:6: can inline (*counter).incrementByReference
	./main.go:9:6: can inline counter.incrementByValue
	./main.go:14:6: can inline incrementByReference
	./main.go:18:6: can inline incrementByValue
	./main.go:28:25: inlining call to (*counter).incrementByReference
	./main.go:29:27: inlining call to counter.incrementByValue
	./main.go:30:22: inlining call to incrementByReference
	./main.go:31:23: inlining call to incrementByValue
	./main.go:36:25: inlining call to (*counter).incrementByReference
	./main.go:37:26: inlining call to counter.incrementByValue
	./main.go:38:22: inlining call to incrementByReference
	./main.go:39:24: inlining call to incrementByValue
	<autogenerated>:1: inlining call to counter.incrementByValue
	./main.go:5:7: c does not escape
	./main.go:14:27: c does not escape
	./main.go:18:23: moved to heap: c
	./main.go:24:11: new(counter) does not escape

The example also tests cases when a pointer (`c1`) and a value (`c2`) are incremented. In the case of `c1` since the compiler can know that it's being only used inside `main`, the value can be safely placed on the stack.